---
title: "Take Home Exercise 1"
date: "9 February 2023"
date-modified: "`r Sys.Date()`"
execute: 
  eval: true
  echo: true
  warning: false
editor: visual
---

# 1.0 Overview

## 1.1 Background

This analysis aims to apply appropriate spatial point patterns analysis methods to discover the geographical distribution of functional and non-function water points and their co-locations if any in Osun State, Nigeria.

## 1.2 Task

-   Exploratory Spatial Data Analysis (ESDA)

-   Second-order Spatial Point Pattern Analysis

-   Spatial Correlation Analysis

# 2.0 Setup

## 2.1 Import Packages

-   sf

-   tidyVerse

-   tmap, maptools, kableExtra - Used for visualizing dataframes and plots

```{r}
pacman::p_load(sf, maptools, raster, spatstat, tmap, kableExtra, tidyverse, funModeling, sfdep)
```

# 3.0 Data Wrangling

## 3.1 Datasets Used

```{r}
#| code-fold: true
# initialise a dataframe of our geospatial and aspatial dataset details
datasets <- data.frame(
  Type=c("Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         
         "Aspatial"),
  
  Name=c("geoBoundaries-NGA-ADM2",
         "geoBoundaries-NGA-ADM2",
         "geoBoundaries-NGA-ADM2",
         "geoBoundaries-NGA-ADM2",
         "geoBoundaries-NGA-ADM2",
         "geoBoundaries-NGA-ADM2",
         "nga_admbnda_adm2_osgof_20190417",
         "nga_admbnda_adm2_osgof_20190417",
         "nga_admbnda_adm2_osgof_20190417",
         "nga_admbnda_adm2_osgof_20190417",
         "nga_admbnda_adm2_osgof_20190417",
         "nga_admbnda_adm2_osgof_20190417",
         "nga_admbnda_adm2_osgof_20190417",
         "nga_admbnda_adm2_osgof_20190417",
         
         "WPdx"),
  
  Format=c(".dbf", 
           ".geojson", 
           ".prj", 
           ".shp", 
           ".shx", 
           ".topojson",
           ".CPG",
           ".dbf",
           ".prj",
           ".sbn", 
           ".sbx", 
           ".shp", 
           ".shp", 
           ".shx", 
          
           ".csv"),
  
  Source=c("[geoBoundaries](https://www.geoboundaries.org/index.html#getdata)",
           "[geoBoundaries](https://www.geoboundaries.org/index.html#getdata)",
           "[geoBoundaries](https://www.geoboundaries.org/index.html#getdata)",
           "[geoBoundaries](https://www.geoboundaries.org/index.html#getdata)",
           "[geoBoundaries](https://www.geoboundaries.org/index.html#getdata)",
           "[geoBoundaries](https://www.geoboundaries.org/index.html#getdata)",
           
          "[Humanitarian Data Exchange](https://data.humdata.org/dataset/cod-ab-nga)",
           "[Humanitarian Data Exchange](https://data.humdata.org/dataset/cod-ab-nga)",
           "[Humanitarian Data Exchange](https://data.humdata.org/dataset/cod-ab-nga)",
           "[Humanitarian Data Exchange](https://data.humdata.org/dataset/cod-ab-nga)",
           "[Humanitarian Data Exchange](https://data.humdata.org/dataset/cod-ab-nga)",
           "[Humanitarian Data Exchange](https://data.humdata.org/dataset/cod-ab-nga)",
           "[Humanitarian Data Exchange](https://data.humdata.org/dataset/cod-ab-nga)",
           "[Humanitarian Data Exchange](https://data.humdata.org/dataset/cod-ab-nga)",
           
           "[ WPdx Global Data Repositories](https://www.waterpointdata.org/access-data/)")
  )

# with reference to this guide on kableExtra:
# https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html
# kable_material is the name of the kable theme
# 'hover' for to highlight row when hovering, 'scale_down' to adjust table to fit page width
library(knitr)
library(kableExtra)
kable(datasets, caption="Datasets Used") %>%
  kable_material("hover", latex_options="scale_down")

```

## 3.2 Geospatial Data

### 3.2.1 Load Data

::: panel-tabset
#### Import

```{r}
osun <- st_read(dsn = "data/geospatial/",
               layer = "nga_admbnda_adm2_osgof_20190417") %>%
  filter(ADM1_EN == "Osun") %>%
  st_transform(crs = 26392)
```

#### Glimpse

```{r}
glimpse(osun)
```
:::

### 3.2.2 Data Preprocessing

#### 3.2.2.1 Exclude redundant fields

```{r}
osun <- osun %>%
  select(c(3:4, 8:9))
```

#### 3.2.2.2 Invalid Geometries

```{r}
length(which(st_is_valid(osun) == FALSE))
```

Everything is valid

#### 3.2.2.3 Checking for Duplicate Names

```{r}
osun$ADM2_EN[duplicated(osun$ADM2_EN)==TRUE]
```

No duplicate Local Government Areas (LGAs)

#### 3.2.2.4 Remove Missing Values

```{r}
osun[rowSums(is.na(osun))!=0,]
```

### 3.2.3 Initial Visualisation

```{r}
plot(st_geometry(osun), main="Osun State")
```

## 3.3 Aspatial Data

### 3.3.1 Load Data

::: panel-tabset
#### Import

```{r}
wp <- read_csv("data/aspatial/WPdx.csv") %>%
  filter(`#clean_country_name` == "Nigeria" & `#clean_adm1` == "Osun")
```

#### Glimpse

```{r}
glimpse(wp)
```
:::

### 3.3.2 Data Preprocessing

#### 3.3.2.1 Create sfc object column

First convert wkt field into sfc field. Then convert it into sf object.

```{r}
wp$Geometry = st_as_sfc(wp$`New Georeferenced Column`)
wp$Geometry
```

#### 3.3.2.2 Create Simple Feature DataFrame

```{r}
wp_sf <- st_sf(wp, crs=4326)

wp_sf <- wp_sf %>%
  st_transform(crs = 26392)
```

#### 3.3.2.3 Handle Missing Data

```{r}
freq(data = wp_sf,
     input = '#status_clean')
```

There are eight classes in the #status_clean fields.

To change NA with "unknown"

```{r}
wp_sf <- wp_sf %>% 
  rename(status_clean = '#status_clean') %>%
  select(status_clean) %>%
  mutate(status_clean = replace_na(
    status_clean, "unknown"))
```

### 3.3.3 Extract Water Points

Functional Points

```{r}
wp_f <- wp_sf %>%
  filter(status_clean %in%
           c("Functional",
             "Functional but needs repair",
             "Functional but not in use"))
```

Non-Functional Points

```{r}
wp_nf <- wp_sf %>%
  filter(status_clean %in%
           c("Non-Functional",
             "Non-Functional due to dry season",
             "Abandoned",
             "Abandoned/Decommissioned"))
```

Unknown Status Points

```{r}
wp_u <- wp_sf %>%
  filter(status_clean == "unknown")
```

::: panel-tabset
#### Functional

```{r}
freq(data = wp_f,
     input = 'status_clean')
```

#### Non-Functional

```{r}
freq(data = wp_nf,
     input = 'status_clean')
```

#### Unknown

```{r}
freq(data = wp_u,
     input = 'status_clean')
```
:::

### 3.3.4 Point-in-Polygon Count

Extract number of total, functional, nonfunctional and unknown water points

```{r}
wp <- osun %>% 
  mutate(`total_wp` = lengths(st_intersects(osun, wp_sf))) %>%
  mutate(`wp_f` = lengths(st_intersects(osun, wp_f))) %>%
  mutate(`wp_nf` = lengths(st_intersects(osun, wp_nf))) %>%
  mutate(`wp_u` = lengths(st_intersects(osun, wp_u)))
```

To save as rds format

```{r}
#write_rds(wp, "Data/rds/wp.rds")
```

```{r}
ggplot(data = wp,
       aes(x = total_wp)) + 
  geom_histogram(bins=20,
                 color="black",
                 fill="light blue") +
  geom_vline(aes(xintercept=mean(
    total_wp, na.rm=T)),
             color="red", 
             linetype="dashed", 
             size=0.8) +
  ggtitle("Distribution of total water points by LGA") +
  xlab("No. of water points") +
  ylab("No. of LGAs") 
```

## 3.4 Combined Data Wrangling

### 3.4.1 Convert sf dataframes to sp Spatial\* class

```{r}
wp_f_spat = as_Spatial(wp_f)
wp_nf_spat = as_Spatial(wp_nf)
osun_spat = as_Spatial(osun)
```

Peek

::: panel-tabset
#### Functional

```{r}
wp_f_spat
```

#### Non-Functional

```{r}
wp_nf_spat
```

#### NGA

```{r}
osun_spat
```
:::

### 3.4.2 Convert sp Spatial\* to generic sp format

```{r}
wp_f_sp <- as(wp_f_spat, "SpatialPoints")
wp_nf_sp <- as(wp_nf_spat, "SpatialPoints")
osun_sp <-as(osun_spat, "SpatialPolygons")
```

Peek

::: panel-tabset
#### Functional

```{r}
wp_f_sp
```

#### Non-Functional

```{r}
wp_nf_sp
```

#### NGA

```{r}
osun_sp
```
:::

### 3.4.3 Convert generic sp to spatstat ppp format

```{r}
# from sp object, convert into ppp format
wp_f_ppp <- as(wp_f_sp, "ppp")
wp_nf_ppp <- as(wp_nf_sp, "ppp")
```

View

```{r}
par(mfrow=c(1,2))
plot(wp_f_ppp, main="Functional")
plot(wp_nf_ppp, main="Non-functional")
```

#### 3.4.3.1 Check for Duplication

```{r}
any(duplicated(wp_f_ppp)); any(duplicated(wp_nf_ppp)) 
```

No duplicates means no jittering needed

### 3.4.4 Create Owin object

```{r}
osun_owin <- as(osun_sp, "owin")
plot(osun_owin, main="Owin object of Osun State")
```

### 3.4.4 Combine point event object with Owin object

```{r}
wp_f_ppp = wp_f_ppp[osun_owin]
wp_nf_ppp = wp_nf_ppp[osun_owin]
```

View

```{r}
#| code-fold: true
par(mfrow=c(1,2))
plot(wp_f_ppp, main="Functional")
plot(wp_nf_ppp, main="Non-functional")
```

# 4.0 Exploratory Spatial Data Analysis (ESDA)

-   Derive kernel density maps of functional and non-functional water points

-   Display kernel density maps of Osun State

-   Describe spatial patterns displayed by the kernel density maps

## 4.1 Initial Visualization

::: panel-tabset
### Visual 1

```{r}
#| code-fold: true
wp_f_1 <- tm_shape(wp) +
  tm_fill("wp_f",
          n = 10,
          style = "equal",
          palette = "Blues") +
  tm_borders(lwd = 0.1,
             alpha = 1) +
  tm_layout(main.title = "Functional Water Points by LGA",
            legend.outside = FALSE)

wp_f_2 <- tm_shape(wp) +
  tm_fill("wp_nf",
          n = 10,
          style = "equal",
          palette = "Blues") +
  tm_borders(lwd = 0.1,
             alpha = 1) +
  tm_layout(main.title = "Non-functional Water Points by LGA",
            legend.outside = FALSE)


tmap_arrange(wp_f_1, wp_f_2, nrow = 1)
```

### Visual 2

```{r}
#| code-fold: true
tmap_mode("view") + 
tm_basemap("OpenStreetMap") +
tm_shape(wp_functional) +
 tm_dots(col = "status_clean",
         pal = "blue",
         border.col = "black",
         title = "Functional") +
tm_shape(wp_nonfunctional) +
 tm_dots(col = "status_clean",
         pal = "purple",
         border.col = "black",
         title = "Non-Functional") +
  tm_view(set.bounds = c(4,7,5,8),
          set.zoom.limits = c(8,15)) 
```
:::

## 4.1 Kernel Density Estimation (KDE)

::: panel-tabset
### Automatic Bandwidth

```{r}
kde_wp_f <- density(wp_f_ppp, 
                    sigma=bw.ppl, 
                    edge=TRUE,
                    kernel = "gaussian")

kde_wp_nf <- density(wp_nf_ppp,
                     sigma=bw.ppl,
                     edge=TRUE,
                     kernel = "gaussian")

par(mfrow=c(1,2))
plot(kde_wp_f, 
     main = "Functional Water Points (in m)",
     ribside=c("bottom"))
plot(kde_wp_nf,
     main = "Non-Functional Water Points (in m)",
     ribside=c("bottom"))
```

### Adaptive Bandwidth

```{r}
kde_wp_f_ad <- adaptive.density(wp_f_ppp,
                                  method = "kernel")

kde_wp_nf_ad <- adaptive.density(wp_nf_ppp,
                                     method = "kernel")

par(mfrow=c(1,2))
plot(kde_wp_f_ad,
     main = "Functional Water Points (in m)",
     ribside=c("bottom"))
plot(kde_wp_nf_ad,
     main = "Non-Functional Water Points (in m)",
     ribside=c("bottom"))
```
:::

### 4.2.1 Re-Scale KDE values

From m to km

```{r}
wp_f_ppp.km <- rescale(wp_f_ppp, 1000, "km")
wp_nf_ppp.km <- rescale(wp_nf_ppp, 1000, "km")
```

::: panel-tabset
#### Automatic Bandwidth

```{r}
kde_wp_f_scale <- density(wp_f_ppp.km,
                          sigma = bw.ppl,
                          edge = TRUE)

kde_wp_nf_scale <- density(wp_f_ppp.km,
                             sigma = bw.ppl,
                             edge = TRUE)

par(mfrow=c(1,2))
plot(kde_wp_f_scale,
     main = "Functional Water Points (in km)",
     ribside=c("bottom"))
plot(kde_wp_nf_scale,
     main = "Non-Functional Water Points (in km)",
     ribside=c("bottom"))
```

#### Adaptive Bandwidth

```{r}
kde_wp_f_scale_ad <- adaptive.density(wp_f_ppp.km,
                                  method = "kernel")

kde_wp_nf_scale_ad <- adaptive.density(wp_nf_ppp.km,
                                     method = "kernel")

par(mfrow=c(1,2))
plot(kde_wp_f_scale_ad,
     main = "Functional Water Points",
     ribside=c("bottom"))
plot(kde_wp_nf_scale_ad,
     main = "Non-Functional Water Points",
     ribside=c("bottom"))
```
:::

### 4.2.2 Re-Scale KDE values

::: panel-tabset
## Automatic Bandwidth

```{r}
grid_wp_f <- as.SpatialGridDataFrame.im(kde_wp_f_scale)
grid_wp_nf <- as.SpatialGridDataFrame.im(kde_wp_nf_scale)

spplot(grid_wp_f)
spplot(grid_wp_nf)
```

## Adaptive Bandwidth

```{r}
grid_wp_f_ad <- as.SpatialGridDataFrame.im(kde_wp_f_scale_ad)
grid_wp_nf_ad <- as.SpatialGridDataFrame.im(kde_wp_nf_scale_ad)

spplot(grid_wp_f_ad)
spplot(grid_wp_nf_ad)
```
:::

### 4.2.3 Convert grid object to Raster

::: panel-tabset
#### Functional

```{r}
kde_wp_f_raster <- raster(grid_wp_f)
kde_wp_f_raster
```

#### Non-Functional

```{r}
kde_wp_nf_raster <- raster(grid_wp_nf)
kde_wp_nf_raster
```
:::

### 4.2.4 Assign Projection System

::: panel-tabset
#### Functional

```{r}
projection(kde_wp_f_raster) <- CRS("+init=EPSG:26391 +datum:WGS84 +units=km")
kde_wp_f_raster
```

#### Non-Functional

```{r}
projection(kde_wp_nf_raster) <- CRS("+init=EPSG:26391 +datum:WGS84 +units=km")
kde_wp_nf_raster
```
:::

## 4.2 Visualize KDE

```{r}
#| code-fold: true
#tmap generation function

density_map <- function(raster_object, map_title) {
  tmap_mode("view")
  #tm_basemap("OpenStreetMap") +
tm_shape(raster_object) +
  tm_raster("v", alpha=0.9, palette=c("white","blue")) +
  tm_view(set.bounds = c(4,7,5,8),
          set.zoom.limits = c(8, 13))
  } 
```

::: panel-tabset
### Functional

```{r}
density_map(kde_wp_f_raster)
```

### Non-Functional

```{r}
density_map(kde_wp_nf_raster)
```
:::

## 4.3 Nearest Neighbor Index

Clarke-Evans Test to check if distribution is random, clustered or dispersed with a 95% confidence interval

### 4.3.1 Test - Functional Water Points

The test hypotheses for Functional Water Point is :

**H~0~ :** The distribution is random

**H~1~ :** The distribution is not random

```{r}
clarkevans.test(wp_f_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("clustered"),
                nsim=99)
```

### 4.3.2 Test - Non-Functional Water Points

The test hypotheses for Non-Functional Water Point is :

**H~0~ :** The distribution is random

**H~1~ :** The distribution is not random (clustered)

```{r}
clarkevans.test(wp_nf_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("clustered"),
                nsim=99)
```

### 4.3.3 Conclusion

As the p-value is less than 0.05 is statistically significant and R\<1 for both functional and non-functional water points, we reject the null hypothesis that the distribution is not random and conclude that the **water points are likely clustered**.

# 5.0 2nd Order Spatial Point Pattern Analysis

-   Formulate the null hypothesis and alternative hypothesis and select the confidence level.

-   Perform the test by using appropriate Second order spatial point patterns analysis technique.

-   With reference to the analysis results, draw statistical conclusions.

## 5.1 Functional Water Points

The test hypotheses for Functional Water Point is :

**H~0~ :** The distribution is random

**H~1~ :** The distribution is not random

### 5.1.1 G-Function

```{r}
#G_wp_f = Gest(wp_f_ppp, correction = "border")
#plot(G_wp_f)
```

Complete Spatial Randomness Test

::: panel-tabset
#### Plot

```{r}
#plot(G_wp_f.csr, main="G test - Functional")
```

#### Simulation

```{r}
#G_wp_f.csr <- envelope(wp_f_ppp, Gest, nsim = 999)
```
:::

### 5.1.2 F-Function

```{r}
#F_wp_f = Fest(wp_f_ppp, correction = "border")
#plot(F_wp_f)
```

Complete Spatial Randomness Test

::: panel-tabset
#### Plot

```{r}
#plot(F_wp_f.csr, main="F test - Functional")
```

#### Simulation

```{r}
#F_wp_f.csr <- envelope(wp_f_ppp, Gest, nsim = 999)
```
:::

### 5.1.3 K-Function

```{r}
#K_wp_f = Kest(wp_f_ppp, correction = "Ripley")
#plot(K_ck, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

Complete Spatial Randomness Test

::: panel-tabset
#### Plot

```{r}
#plot(K_wp_functional.csr, . - r ~ r, xlab="d", ylab="K(d)-r", main="K test - Functional")
```

#### Simulation

```{r}
#K_wp_functional.csr <- envelope(wp_functional_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```
:::

### 5.1.4 L-Function

```{r}
#L_wp_f = Lest(wp_f_ppp, correction = "Ripley")
#plot(L_wp_f_ppp, . -r ~ r, ylab= "L(d)-r", xlab = "d(m)")
```

Complete Spatial Randomness Test

::: panel-tabset
#### Plot

```{r}
#plot(L_wp_functional.csr, . - r ~ r, xlab="d", ylab="L(d)-r", main="L test - Functional")
```

#### Simulation

```{r}
#L_wp_functional.csr <- envelope(wp_functional_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```
:::

## 5.2 Non-Functional Water Points

The test hypotheses for Non-Functional Water Point is :

**H~0~ :** The distribution is random

**H~1~ :** The distribution is not random

### 5.2.1 G-Function

```{r}
#G_wp_nf = Gest(wp_nf_ppp, correction = "border")
#plot(G_wp_nf)
```

Complete Spatial Randomness Test

::: panel-tabset
#### Plot

```{r}
#plot(G_wp_nf.csr,  main = "G test - Non-functional")
```

#### Simulation

```{r}
#G_wp_nf.csr <- envelope(wp_nf_ppp, Gest, nsim = 999)
```
:::

### 5.2.2 F-Function

```{r}
#F_wp_nf = Fest(wp_nf_ppp, correction = "border")
#plot(F_wp_nf)
```

Complete Spatial Randomness Test

::: panel-tabset
#### Plot

```{r}
#plot(F_wp_ff.csr, main="F test - Non-functional")
```

#### Simulation

```{r}
#F_wp_nf.csr <- envelope(wp_f_ppp, Gest, nsim = 999)
```
:::

### 5.2.3 K-Function

```{r}
#K_wp_nf = Kest(wp_nf_ppp, correction = "Ripley")
#plot(K_ck, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

Complete Spatial Randomness Test

::: panel-tabset
#### Plot

```{r}
#plot(K_wp_nf.csr, . - r ~ r, xlab="d", ylab="K(d)-r", main="K test - Non-functional")
```

#### Simulation

```{r}
#K_wp_nf.csr <- envelope(wp_f_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```
:::

### 5.2.4 L-Function

```{r}
#L_wp_nf = Lest(wp_nf_ppp, correction = "Ripley")
#plot(L_wp_nf_ppp, . -r ~ r, ylab= "L(d)-r", xlab = "d(m)")
```

Complete Spatial Randomness Test

::: panel-tabset
#### Plot

```{r}
#plot(L_wp_nf.csr, . - r ~ r, xlab="d", ylab="L(d)-r", main="L test - Non-functional")
```

#### Simulation

```{r}
#L_wp_nf.csr <- envelope(wp_nf_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```
:::

## 5.3 Conclusion

Something

# 6.0 Spatial Correlation Analysis

-   Formulate the null hypothesis and alternative hypothesis and select the confidence level.

-   Perform the test by using appropriate Second order spatial point patterns analysis technique.

-   With reference to the analysis results, draw statistical conclusions.

## 6.1 Hypothesis

Something

## 6.2 Test

```{r}
nb = include_self(st_knn(st_geometry(wp_sf_nga), 6))

wt = st_kernel_weights(nb, wp_sf_nga, "gaussian", adaptive = TRUE)
```

```{r}
f = wp_sf %>%
  filter(status_clean == "Functional")

A = f$status_clean
```

```{r}
nf = wp_sf %>%
  filter(status_clean == "Non-Functional")
B = nf$status_clean
```

```{r}
LCLQ = local_colocation(A, B, nb, wt, 49)
```

```{r}
LCLQ_wp = cbind(wp_sf, LCLQ)
```

```{r}
tmap_mode("view")
tm_shape(osun) +
  tm_polygons() +
  tm_shape(LCLQ_wp) +
  tm_dots(col = "status_clean", 
          size = 0.01,
          border.col = "black",
          border.lwd = 0.5) +
  tm_view(set.zoom.limits = c(12, 16))
```

### 6.3 Analysis + Conclusion

To do
