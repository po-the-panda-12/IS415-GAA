---
title: "Take Home Exercise 1"
date: "9 February 2023"
date-modified: "`r Sys.Date()`"
execute: 
  eval: true
  echo: true
  warning: false
editor: visual
---

# 1.0 Overview

## 1.1 Background

This analysis aims to apply appropriate spatial point patterns analysis methods to discover the geographical distribution of functional and non-function water points and their co-locations if any in Osun State, Nigeria.

## 1.2 Task

-   Exploratory Spatial Data Analysis (ESDA)

-   Second-order Spatial Point Pattern Analysis

-   Spatial Correlation Analysis

# 2.0 Setup

## 2.1 Import Packages

-   sf

-   tidyVerse

-   tmap, maptools, kableExtra - Used for visualizing dataframes and plots

```{r}
pacman::p_load(sf, maptools, raster, spatstat, tmap, kableExtra, tidyverse, funModeling, sfdep)
```

# 3.0 Data Wrangling

## 3.1 Datasets Used

```{r}
#| code-fold: true
# initialise a dataframe of our geospatial and aspatial dataset details
datasets <- data.frame(
  Type=c("Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         "Geospatial",
         
         "Aspatial"),
  
  Name=c("geoBoundaries-NGA-ADM2",
         "geoBoundaries-NGA-ADM2",
         "geoBoundaries-NGA-ADM2",
         "geoBoundaries-NGA-ADM2",
         "geoBoundaries-NGA-ADM2",
         "geoBoundaries-NGA-ADM2",
         "nga_admbnda_adm2_osgof_20190417",
         "nga_admbnda_adm2_osgof_20190417",
         "nga_admbnda_adm2_osgof_20190417",
         "nga_admbnda_adm2_osgof_20190417",
         "nga_admbnda_adm2_osgof_20190417",
         "nga_admbnda_adm2_osgof_20190417",
         "nga_admbnda_adm2_osgof_20190417",
         "nga_admbnda_adm2_osgof_20190417",
         
         "WPdx"),
  
  Format=c(".dbf", 
           ".geojson", 
           ".prj", 
           ".shp", 
           ".shx", 
           ".topojson",
           ".CPG",
           ".dbf",
           ".prj",
           ".sbn", 
           ".sbx", 
           ".shp", 
           ".shp", 
           ".shx", 
          
           ".csv"),
  
  Source=c("[geoBoundaries](https://www.geoboundaries.org/index.html#getdata)",
           "[geoBoundaries](https://www.geoboundaries.org/index.html#getdata)",
           "[geoBoundaries](https://www.geoboundaries.org/index.html#getdata)",
           "[geoBoundaries](https://www.geoboundaries.org/index.html#getdata)",
           "[geoBoundaries](https://www.geoboundaries.org/index.html#getdata)",
           "[geoBoundaries](https://www.geoboundaries.org/index.html#getdata)",
           
          "[Humanitarian Data Exchange](https://data.humdata.org/dataset/cod-ab-nga)",
           "[Humanitarian Data Exchange](https://data.humdata.org/dataset/cod-ab-nga)",
           "[Humanitarian Data Exchange](https://data.humdata.org/dataset/cod-ab-nga)",
           "[Humanitarian Data Exchange](https://data.humdata.org/dataset/cod-ab-nga)",
           "[Humanitarian Data Exchange](https://data.humdata.org/dataset/cod-ab-nga)",
           "[Humanitarian Data Exchange](https://data.humdata.org/dataset/cod-ab-nga)",
           "[Humanitarian Data Exchange](https://data.humdata.org/dataset/cod-ab-nga)",
           "[Humanitarian Data Exchange](https://data.humdata.org/dataset/cod-ab-nga)",
           
           "[ WPdx Global Data Repositories](https://www.waterpointdata.org/access-data/)")
  )

# with reference to this guide on kableExtra:
# https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html
# kable_material is the name of the kable theme
# 'hover' for to highlight row when hovering, 'scale_down' to adjust table to fit page width
library(knitr)
library(kableExtra)
kable(datasets, caption="Datasets Used") %>%
  kable_material("hover", latex_options="scale_down")

```

## 3.2 Geospatial Data

### 3.2.1 Load Data

::: panel-tabset
#### Import

```{r}
NGA <- st_read("data/geospatial", 
                  layer = "nga_admbnda_adm2_osgof_20190417") %>%
  filter(ADM1_EN == "Osun") %>%
  st_transform(crs = 26392)
```

#### Glimpse

```{r}
glimpse(NGA)
```
:::

### 3.2.2 Data Preprocessing

#### 3.2.2.1 Exclude redundant fields

```{r}
NGA <- NGA %>%
  select(c(3:4, 8:9)) #dplyr
```

#### 3.2.2.2 Invalid Geometries

```{r}
length(which(st_is_valid(NGA) == FALSE))
```

Everything is valid

#### 3.2.2.3 Checking for Duplicate Names

```{r}
NGA$ADM2_EN[duplicated(NGA$ADM2_EN)==TRUE]
```

No duplicate names

#### 3.2.2.4 Remove Missing Values

```{r}
NGA[rowSums(is.na(NGA))!=0,]
```

### 3.2.3 Initial Visualisation

```{r}
plot(st_geometry(NGA))
```

## 3.3 Aspatial Data

### 3.3.1 Load Data

::: panel-tabset
#### Import

```{r}
wp_nga <- read_csv("data/aspatial/WPdx.csv") %>%
  filter(`#clean_country_name` == "Nigeria" & `#clean_adm1` == "Osun")
```

#### Glimpse

```{r}
glimpse(wp_nga)
```
:::

### 3.3.2 Data Preprocessing

#### 3.3.2.1 Convert point data to sf point features

First convert wkt field into sfc field. Then convert it into sf object.

```{r}
wp_nga$Geometry = st_as_sfc(wp_nga$`New Georeferenced Column`)

wp_sf <- st_sf(wp_nga, crs=4326)
```

#### 3.3.2.2 Transform into Coordinate System

```{r}
wp_sf <- wp_sf %>%
  st_transform(crs = 26392)
```

#### 3.3.2.3 Handle Missing Data

```{r}
freq(data = wp_sf,
     input = '#status_clean')
```

There are eight classes in the #status_clean fields.

To change NA with "unknown"

```{r}
wp_sf_nga <- wp_sf %>% 
  rename(status_clean = '#status_clean') %>%
  select(status_clean) %>%
  mutate(status_clean = replace_na(
    status_clean, "unknown"))
```

### 3.3.3 Water Point Extraction

Functional Points

```{r}
wp_functional <- wp_sf_nga %>%
  filter(status_clean %in%
           c("Functional",
             "Functional, needs repair",
             "Functional, not in use",
             "Functional but not in use"))
```

Non-Functional Points

```{r}
wp_nonfunctional <- wp_sf_nga %>%
  filter(status_clean %in%
           c("Abandoned/Decommissioned",
             "Non-Functional, dry",
             "Non-Functional"))
```

Unknown Status Points

```{r}
wp_unknown <- wp_sf_nga %>%
  filter(status_clean == "unknown")
```

::: panel-tabset
#### Functional

```{r}
freq(data = wp_functional,
     input = 'status_clean')
```

#### Non-Functional

```{r}
freq(data = wp_nonfunctional,
     input = 'status_clean')
```

#### Unknown

```{r}
freq(data = wp_unknown,
     input = 'status_clean')
```
:::

### 3.3.4 Point-in-Polygon Count

Extract number of total, functional, nonfunctional and unknown water points

```{r}
NGA_wp <- NGA %>% 
  mutate(`total_wp` = lengths(
    st_intersects(NGA, wp_sf_nga))) %>%
  mutate(`wp_functional` = lengths(
    st_intersects(NGA, wp_functional))) %>%
  mutate(`wp_nonfunctional` = lengths(
    st_intersects(NGA, wp_nonfunctional))) %>%
  mutate(`wp_unknown` = lengths(
    st_intersects(NGA, wp_unknown)))
```

## 3.4 Combined Data Wrangling

### 3.4.1 Convert sf dataframes to sp Spatial class

```{r}
wp_functional_spat = as_Spatial(wp_functional)
wp_nonfunctional_spat = as_Spatial(wp_nonfunctional)
NGA_spat = as_Spatial(NGA)
```

Peek

::: panel-tabset
#### Functional

```{r}
wp_functional_spat
```

#### Non-Functional

```{r}
wp_nonfunctional_spat
```

#### NGA

```{r}
NGA_spat
```
:::

### 3.4.2 Convert sp Spatial to generic sp format

```{r}
wp_functional_sp <- as(wp_functional_spat, "SpatialPoints")
wp_nonfunctional_sp <- as(wp_nonfunctional_spat, "SpatialPoints")
NGA_sp <-as(NGA_spat, "SpatialPolygons")
```

Peek

::: panel-tabset
#### Functional

```{r}
wp_functional_sp
```

#### Non-Functional

```{r}
wp_nonfunctional_sp
```

#### NGA

```{r}
NGA_sp
```
:::

### 3.4.3 Convert generic sp to spatstat ppp format

```{r}
# from sp object, convert into ppp format
wp_functional_ppp <- as(wp_functional_sp, "ppp")
wp_nonfunctional_ppp <- as(wp_nonfunctional_sp, "ppp")
```

View

```{r}
par(mfrow=c(1,2))
plot(wp_functional_ppp)
plot(wp_nonfunctional_ppp)
```

#### 3.4.3.1 Check for Duplication

```{r}
any(duplicated(wp_functional_ppp)); any(duplicated(wp_nonfunctional_ppp)) 
```

No duplicates means no jittering needed

### 3.4.4 Create Owin object

```{r}
NGA_owin <- as(NGA_sp, "owin")
plot(NGA_owin)
```

### 3.4.4 Combine point event object with Owin object

```{r}
wp_functional_ppp = wp_functional_ppp[NGA_owin]
wp_nonfunctional_ppp = wp_nonfunctional_ppp[NGA_owin]
```

View

```{r}
#| code-fold: true
par(mfrow=c(1,2))
plot(wp_functional_ppp)
plot(wp_nonfunctional_ppp)
```

# 4.0 Exploratory Spatial Data Analysis (ESDA)

-   Derive kernel density maps of functional and non-functional water points

-   Display kernel density maps of Osun State

-   Describe spatial patterns displayed by the kernel density maps

## 4.1 Kernel Density Estimation (KDE)

::: panel-tabset
### Automatic Bandwidth

```{r}
kde_wpfunc.mppl <- density(wp_functional_ppp, 
                               sigma=bw.ppl, 
                               edge=TRUE)

kde_wpnonfunc.mppl <- density(wp_nonfunctional_ppp,
                             sigma=bw.ppl,
                             edge=TRUE)

par(mfrow=c(1,2))
plot(kde_wpfunc.mppl, 
     main = "Functional Water Points",
     ribside=c("bottom"))
plot(kde_wpnonfunc.mppl,
     main = "Non-Functional Water Points",
     ribside=c("bottom"))
```

### Adaptive Bandwidth

```{r}
kde_wpfunc.m <- adaptive.density(wp_functional_ppp,
                                  method = "kernel")

kde_wpnonfunc.m <- adaptive.density(wp_nonfunctional_ppp,
                                     method = "kernel")

par(mfrow=c(1,2))
plot(kde_wpfunc.m,
     main = "Functional Water Points",
     ribside=c("right"))
plot(kde_wpnonfunc.m,
     main = "Non-Functional Water Points",
     ribside=c("right"))
```
:::

### 4.2.1 Re-Scale KDE values

```{r}
wp_functional_ppp.km <- rescale(wp_functional_ppp, 1000, "km")

wp_nonfunctional_ppp.km <- rescale(wp_nonfunctional_ppp, 1000, "km")
```

::: panel-tabset
#### Automatic Bandwidth

```{r}
kde_wpfunc.ppl <- density(wp_functional_ppp.km,
                          sigma = bw.ppl,
                          edge = TRUE)

kde_wpnonfunc.ppl <- density(wp_nonfunctional_ppp.km,
                             sigma = bw.ppl,
                             edge = TRUE)

par(mfrow=c(1,2))
plot(kde_wpfunc.ppl,
     main = "Functional Water Points",
     ribside=c("bottom"))
plot(kde_wpnonfunc.ppl,
     main = "Non-Functional Water Points",
     ribside=c("bottom"))
```

#### Adaptive Bandwidth

```{r}
kde_wpfunc.km <- adaptive.density(wp_functional_ppp.km,
                                  method = "kernel")

kde_wpnonfunc.km <- adaptive.density(wp_nonfunctional_ppp.km,
                                     method = "kernel")

par(mfrow=c(1,2))
plot(kde_wpfunc.km,
     main = "Functional Water Points",
     ribside=c("bottom"))
plot(kde_wpnonfunc.km,
     main = "Non-Functional Water Points",
     ribside=c("bottom"))
```
:::

### 4.2.2 Re-Scale KDE values

::: panel-tabset
## Automatic Bandwidth

```{r}
gridded_wpfunc.ppl <- as.SpatialGridDataFrame.im(kde_wpfunc.ppl)
gridded_wpnonfunc.ppl <- as.SpatialGridDataFrame.im(kde_wpnonfunc.ppl)

spplot(gridded_wpfunc.ppl)
spplot(gridded_wpnonfunc.ppl)
```

## Adaptive Bandwidth

```{r}
gridded_wpfunc <- as.SpatialGridDataFrame.im(kde_wpfunc.km)
gridded_wpnonfunc <- as.SpatialGridDataFrame.im(kde_wpnonfunc.km)

spplot(gridded_wpfunc)
spplot(gridded_wpnonfunc)
```
:::

### 4.2.3 Convert grid object to Raster

::: panel-tabset
#### Functional

```{r}
kde_wpfunc_raster <- raster(gridded_wpfunc)
kde_wpfunc_raster
```

#### Non-Functional

```{r}
kde_wpnonfunc_raster <- raster(gridded_wpnonfunc)
kde_wpnonfunc_raster
```
:::

### 4.2.4 Assign Projection System

::: panel-tabset
#### Functional

```{r}
projection(kde_wpfunc_raster) <- CRS("+init=EPSG:26391 +datum:WGS84 +units=km")
kde_wpfunc_raster
```

#### Non-Functional

```{r}
projection(kde_wpnonfunc_raster) <- CRS("+init=EPSG:26391 +datum:WGS84 +units=km")
kde_wpnonfunc_raster
```
:::

## 4.2 Visualize KDE

```{r}
#| code-fold: true
#tmap generation function
density_map <- function(raster_object, map_title) {
  tmap_mode("view")
  tm_basemap("OpenStreetMap") +
tm_shape(raster_object) +
  tm_raster("v", alpha=0.9) +
  tm_view(set.bounds = c(4,7,5,8),
          set.zoom.limits = c(8, 13))
  } 
```

::: panel-tabset
### Functional

```{r}
density_map(kde_wpfunc_raster)
```

### Non-Functional

```{r}
density_map(kde_wpnonfunc_raster)
```
:::

## 4.3 Nearest Neighbor Index

Clarke-Evans Test to check if distribution is random, clustered or dispersed with a 95% confidence interval

### 4.3.1 Test - Functional Water Points

The test hypotheses for Functional Water Point is :

**H~0~ :** The distribution is random

**H~1~ :** The distribution is not random

```{r}
clarkevans.test(wp_functional_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("clustered"),
                nsim=99)
```

### 4.3.2 Test - Non-Functional Water Points

The test hypotheses for Non-Functional Water Point is :

**H~0~ :** The distribution is random

**H~1~ :** The distribution is not random

```{r}
clarkevans.test(wp_nonfunctional_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("clustered"),
                nsim=99)
```

### 4.3.3 Conclusion

Something

# 5.0 2nd Order Spatial Point Pattern Analysis

## 5.1 Functional Water Points

### 5.1.1 F-Function

```{r}
#G_wp_functional = Gest(wp_functional_ppp, correction = "border")
#plot(G_wp_functional)
```

Spatial Randomness Test

::: panel-tabset
#### Plot

```{r}
#plot(G_wp_functional.csr)
```

#### Simulation

```{r}
#G_wp_functional.csr <- envelope(wp_functional_ppp, Gest, nsim = 999)
```
:::

### 5.1.2 K-Function

```{r}
#K_wp_functional = Kest(wp_functional_ppp, correction = "Ripley")
#plot(K_ck, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

Spatial Randomness

::: panel-tabset
#### Plot

```{r}
#plot(K_wp_functional.csr, . - r ~ r, xlab="d", ylab="K(d)-r", title="K test - Functional")
```

#### Simulation

```{r}
#K_wp_functional.csr <- envelope(wp_functional_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```
:::

### 5.1.3 L-Function

```{r}
#L_wp_functional = Lest(wp_functional_ppp, correction = "Ripley")
#plot(L_wp_functional_ppp, . -r ~ r, ylab= "L(d)-r", xlab = "d(m)")
```

Spatial Randomness

::: panel-tabset
#### Plot

```{r}
#plot(L_wp_functional.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

#### Simulation

```{r}
#L_wp_functional.csr <- envelope(wp_functional_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```
:::

## 5.2 Non-Functional Water Points

### 5.2.1 F-Function

```{r}
#G_wp_nonfunctional = Gest(wp_functional_ppp, correction = "border")
#plot(G_wp_nonfunctional)
```

Spatial Randomness Test

::: panel-tabset
#### Plot

```{r}
#plot(G_wp_nonfunctional.csr)
```

#### Simulation

```{r}
#G_wp_nonfunctional.csr <- envelope(wp_functional_ppp, Gest, nsim = 999)
```
:::

### 5.1.2 K-Function

```{r}
#K_wp_nonfunctional = Kest(wp_nonfunctional_ppp, correction = "Ripley")
#plot(K_ck, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

Spatial Randomness

::: panel-tabset
#### Plot

```{r}
#plot(K_wp_nonfunctional.csr, . - r ~ r, xlab="d", ylab="K(d)-r", title="K test - Functional")
```

#### Simulation

```{r}
#K_wp_nonfunctional.csr <- envelope(wp_functional_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```
:::

### 5.1.3 L-Function

```{r}
#L_wp_nonfunctional = Lest(wp_nonfunctional_ppp, correction = "Ripley")
#plot(L_wp_nonfunctional_ppp, . -r ~ r, ylab= "L(d)-r", xlab = "d(m)")
```

Spatial Randomness

::: panel-tabset
#### Plot

```{r}
#plot(L_wp_nonfunctional.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

#### Simulation

```{r}
#L_wp_nonfunctional.csr <- envelope(wp_nonfunctional_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```
:::

## 5.3 Conclusion

Something

# 6.0 Spatial Correlation Analysis

## 6.1 Hypothesis

Something

## 6.2 Test

```{r}
nb = include_self(st_knn(st_geometry(wp_sf_nga), 6))

wt = st_kernel_weights(nb, wp_sf_nga, "gaussian", adaptive = TRUE)
```

```{r}
functional = wp_sf_nga %>%
  filter(status_clean %in%
           c("Functional",
             "Functional, needs repair",
             "Function, not in use",
             "Functional but not in use"))

A = functional$status_clean
```

```{r}
nonfunctional = wp_sf_nga %>%
  filter(status_clean %in%
           c("Abandoned/Decommissioned",
             "Non-Functional, dry",
             "Non-Functional"))
B = nonfunctional$status_clean
```

```{r}
LCLQ = local_colocation(A, B, nb, wt, 49)
```

```{r}
LCLQ_wp = cbind(wp_sf_nga, LCLQ)
```

```{r}
tmap_mode("view")
tm_shape(NGA)+
  tm_polygons()+
tm_shape(LCLQ_wp)+
  tm_dots(col = c("Abandoned.Decommissioned", "Non.Functional", "Non.Functional..dry"),
          size = 0.01,
          border.col = "black",
          border.lwd = 0.5) +
  tm_view(set.zoom.limits = c(8, 13))
```

### 6.3 Analysis + Conclusion
